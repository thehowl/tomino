{{/*
Go generator.
Go templates are a bit of a mess, but preferable to writing this by hand.
Reference: https://pkg.go.dev/text/template
Additional functions:
	throw (format string, args ...any)
		Create an error to stop execution of the template.
	uvarint (n number)
		Get the uvarint bytes for n. n can be of any type convertible to uint64.
	gotag (p []uint8)
		Create list of bytes to be used with append.
		Prints them as hex characters if len(p) > 1, or as a broken-down
		combination of record number + type if len(p) == 1.
*/}}

{{/* Used to "stringify" a type.
	Parameter: Record */}}
{{ define "type" }}
{{- if eq .Kind "struct" -}}
struct {
	{{- range .Fields }}
	{{ .Name }} {{ template "type" .Record }} `json:"{{ .JSONName }}
		{{- if .Has "json_omit_empty" -}},omitempty{{- end -}}"
		{{- if .Has "fixed64" }} binary:"fixed64"{{- end }}
		{{- if .Has "fixed32" }} binary:"fixed32"{{- end }}`
	{{- end }}{{/*- TODO: Reconstruct more tags */}}
}
{{- else if eq .Kind "repeated" -}}
	[{{ if ne .Size -1 }}{{ .Size }}{{ end }}]{{ template "type" .Elem }}
{{- else if eq .Kind "scalar" -}}
	{{ .Name }}
{{- else if eq .Kind "optional" -}}
	*{{ template "type" .Elem }}
{{- else if eq .Kind "bytes" -}}
	{{- if .String -}}
		string
	{{- else if ne .Size -1 -}}
		[{{ .Size }}]byte
	{{- else -}}
		[]byte
	{{- end -}}
{{- else -}}
	{{ throw "unknown kind %s" .Kind }}
{{- end -}}
{{ end }}{{/* end "type" */}}


{{/* Used to create an encoder for a type.
	Parameter: StructRecord */}}
{{ define "encoder" }}
{{- if ne .Kind "struct" -}}{{ throw "cannot encode type %s" .Kind }}{{- end -}}
{{/*- TODO: pre-calculate minium sizes for encoding the struct, and grow b accordingly. -*/}}
{{- range .Fields }}
	{{- template "encoder_field" . -}}
{{ end }}
{{ end }}

{{/* Used to create an encoder for a struct field.
	Parameter: StructField. */}}
{{ define "encoder_field" }}
	{{- if eq .Record.Kind "struct" }}
		// field number {{ .BinFieldNum }}
		{{ if eq 0 (len .Record.Fields) }}
			{{ if .Has "write_empty" }}
				// (no fields, just encode 0-length)
				b = append(b, {{ gotag .Tag }}, 0)
			{{ else }}
				// (no fields, skip as there is no write_empty)
			{{ end }}
		{{ else }}
			{
				bprev := &b
				b := make([]byte, 0, 16) {{/*- TODO: better "guess" for cap. */}}
				msg := msg.{{ .Name }}
				{{ template "encoder" .Record }}
				switch {
				case len(b) == 0:
				{{ if .Has "write_empty" }}
					*brev = append(*bprev, {{ gotag .Tag }}0)
				{{ else }}
					// empty -- append nothing
				{{ end }}
				case len(b) <= maxVarint1:
					*bprev = growBytes(*bprev, {{ len .Tag }} + 1 + len(b))
					*bprev = append(*bprev, {{ gotag .Tag }}, byte(len(b)))
					*bprev = append(*bprev, b...)
				case len(b) <= maxVarint2:
					*bprev = growBytes(*bprev, {{ len .Tag }} + 2 + len(b))
					*bprev = append(*bprev,
						{{ gotag .Tag }},
						byte(len(b) | 0x80),
						byte(len(b) >> 7))
					*bprev = append(*bprev, b...)
				default:
					*bprev = growBytes(*bprev, {{ len .Tag }} + 10 + len(b))
					*bprev = append(*bprev, {{ gotag .Tag }})
					uvlen := putUvarint((*bprev)[len(*bprev):len(*bprev)+10], uint64(len(b)))
					*bprev = (*bprev)[:len(*bprev)+uvlen]
					*bprev = append(*bprev, b[2:]...)
				}
			}
		{{ end }}
	{{- else if eq .Record.Kind "repeated" }}
		// field number {{ .BinFieldNum }}
		{{ if eq 0 .Record.Size }} {{/*- [0]T */}}
			{{ if .Has "write_empty" }}
				// (0-element array, just encode 0-length)
				b = append(b, {{ gotag .Tag }}, 0)
			{{ else }}
				// (no fields, skip as there is no write_empty)
			{{ end }}
		{{ else if ne -1 .Record.Size }} {{/*- array */}}
			{{ throw "TODO" }}
		{{ else }} {{/*- slice */}}
			for _, el := range msg.{{ .Name }} {
				msg := struct { {{ .Name }} {{ template "type" .Record.Elem }} }{ el }
				{{ template "encoder_field" (.WithRecord .Record.Elem) }}
			}
		{{ end }}
	{{- else if eq .Record.Kind "scalar" }}
		{{ if (or (.Has "fixed64") (eq .Name "float64")) }}
			{
				u64 := *(*uint64)(unsafe.Pointer(&msg.{{ .Name }})) {{/*- same as math.Float64frombits */}}
				{{ if not (.Has "write_empty") }}if u64 != 0 { {{- end }}
				// field number {{ .BinFieldNum }}
				b = append(b, {{ gotag .Tag }})
				b = growBytes(b, 8)[:len(b)+8]
				putUint64(b[len(b)-8:], u64)
				{{ if not (.Has "write_empty") }} } {{ end }}
			}
		{{ else if (or (.Has "fixed32") (eq .Name "float32")) }}
			{
				u32 := *(*uint32)(unsafe.Pointer(&msg.{{ .Name }})) {{/*- same as math.Float32frombits */}}
				{{ if not (.Has "write_empty") }}if u32 != 0 { {{- end }}
				// field number {{ .BinFieldNum }}
				b = append(b, {{ gotag .Tag }})
				b = growBytes(b, 4)[:len(b)+4]
				putUint32(b[len(b)-4:], u32)
				{{ if not (.Has "write_empty") }} } {{ end }}
			}
		{{ else if eq .Record.Name "bool" }} {{/*- TODO: does using unsafe +direct write make sense here? what's the assembly code? */}}
			if msg.{{ .Name }} {
				// field number {{ .BinFieldNum }}
				b = append(b, {{ gotag .Tag }}, 1)
			}{{ if .Has "write_empty" }} else {
				b = append(b, {{ gotag .Tag }}, 0)
			}{{ end }}
		{{ else if .Record.IsUnsigned }}
			{{ if not (.Has "write_empty") }}if msg.{{ .Name }} != 0 { {{- end }}
			// field number {{ .BinFieldNum }}
			b = append(b, {{ gotag .Tag }})
			b = growBytes(b, 10)
			b = b[:len(b)+putUvarint(b[len(b):len(b)+10], uint64(msg.{{ .Name }}))]
			{{ if not (.Has "write_empty") -}} } {{- end }}
		{{ else }}
			{{ if not (.Has "write_empty") }}if msg.{{ .Name }} != 0 { {{- end }}
			// field number {{ .BinFieldNum }}
			b = append(b, {{ gotag .Tag }})
			b = growBytes(b, 10)
			b = b[:len(b)+putVarint(b[len(b):len(b)+10], int64(msg.{{ .Name }}))]
			{{ if not (.Has "write_empty") -}} } {{- end }}
		{{ end }}
	{{- else if eq .Record.Kind "optional" }}
		if msg.{{ .Name }} != nil {
			// use a new "msg" so we can encode the underlying field directly.
			// with _ = msg, avoid "unused" warnings.
			msg := struct { {{ .Name }} {{ template "type" .Record.Elem }} }{ *msg.{{ .Name }} }
			_ = msg

			{{ template "encoder_field" (.WithRecord .Record.Elem) }}
		}
	{{- else if and (eq .Record.Kind "bytes") (eq .Record.Size -1) }} {{/*- slices */}}
		{{ $f := printf "msg.%s" .Name -}}
		// field number {{ .BinFieldNum }}
		switch {
		case len({{ $f }}) == 0:
		{{ if .Has "write_empty" }}
			b = append(b, {{ gotag .Tag }}, 0)
		{{ else }}
			// nothing to write
		{{ end }}
		case len({{ $f }}) <= maxVarint1:
			b = append(b, {{ gotag .Tag }}, byte(len({{ $f }})))
			b = append(b, {{ $f }}...)
		case len({{ $f }}) <= maxVarint2:
			b = append(b, {{ gotag .Tag }}, byte(len({{ $f }}) | 0x80), byte(len({{ $f }}) >> 7))
			b = append(b, {{ $f }}...)
		default:
			b = growBytes(b, {{ len .Tag }} + 10 + len({{ $f }}))
			b = append(b, {{ gotag .Tag }})
			uvlen := putUvarint(b[len(b):len(b)+10], uint64(len({{ $f }})))
			b = b[:len(b)+uvlen]
			b = append(b, {{ $f }}...)
		}
	{{- else if eq .Record.Kind "bytes" }} {{/*- arrays */}}
		{{- $f := printf "msg.%s" .Name -}}
		// field number {{ .BinFieldNum }}
		{{ if eq .Record.Size 0 }}
			// Skipped (zero-element array)
		{{ else }}
			b = append(b,
				// tag
				{{ gotag .Tag }},
				// size
				{{ range uvarint .Record.Size }}{{ . }}, {{ end }}
			)
			b = append(b, {{ $f }}[:]...)
		{{ end }}
	{{- else -}}
		{{ throw "unknown kind %s" .Record.Kind }}
	{{- end -}}
{{ end }}{{/* end "encoder_field" */}}

{{/* Main entrypoint from Go code.
	Parameter: []StructRecord. */}}
{{ define "main" -}}
// Code generated by tomgen (tomino). DO NOT EDIT.

package tomtypes

import "unsafe"

{{ range . -}}

{{- $name := printf "%sMessage" .Name -}}
// {{ $name }} is the tomino message for the type
// {{ .Source }}
type {{ $name }} {{ template "type" . }}

func (msg {{ $name }}) MarshalBinary() ([]byte, error) {
	return msg.AppendBinary(nil)
}

func (msg {{ $name }}) AppendBinary(b []byte) ([]byte, error) {
	{{ template "encoder" . }}
	return b, nil
}

{{ end }}

// ---
// encoding helpers

const (
	// These are common when encoding lengths, and have fast paths instead of
	// calling putUvarint.
	maxVarint1 = (1 << 7) - 1
	maxVarint2 = (1 << 7) - 1
)

// Non-generic version of slices.Grow.
func growBytes(s []byte, n int) []byte {
	if n -= cap(s) - len(s); n > 0 {
		s = append(s[:cap(s)], make([]byte, n)...)[:len(s)]
	}
	return s
}

// putUvarint encodes a uint64 into buf and returns the number of bytes written.
// If the buffer is too small, PutUvarint will panic.
// Copied from package binary.
func putUvarint(buf []byte, x uint64) int {
	i := 0
	for x >= 0x80 {
		buf[i] = byte(x) | 0x80
		x >>= 7
		i++
	}
	buf[i] = byte(x)
	return i + 1
}

// putVarint encodes an int64 into buf and returns the number of bytes written.
// If the buffer is too small, PutVarint will panic.
func putVarint(buf []byte, x int64) int {
	ux := uint64(x) << 1
	if x < 0 {
		ux = ^ux
	}
	return putUvarint(buf, ux)
}

func putUint64(b []byte, v uint64) {
	_ = b[7] // early bounds check to guarantee safety of writes below
	b[0] = byte(v)
	b[1] = byte(v >> 8)
	b[2] = byte(v >> 16)
	b[3] = byte(v >> 24)
	b[4] = byte(v >> 32)
	b[5] = byte(v >> 40)
	b[6] = byte(v >> 48)
	b[7] = byte(v >> 56)
}

func putUint32(b []byte, v uint32) {
	_ = b[3] // early bounds check to guarantee safety of writes below
	b[0] = byte(v)
	b[1] = byte(v >> 8)
	b[2] = byte(v >> 16)
	b[3] = byte(v >> 24)
}

// avoid unused import errors.
var _ = unsafe.Pointer((*int)(nil))

{{ end }}{{/* end "main" */}}
